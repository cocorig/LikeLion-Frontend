//웹 브라우저의 자바스크립트는 엔진이 다르기때문에 다 다르다-> 실행결과, 문법이 다다름 -> 그래서 각각의 브라우저가 에크마를 따름 -> 하지만 모든 브라우저가 다 같진않다 
// sort(?) -> ?함수 -> 콜백함수  -> 같은 값이 있었을 때 매개변수의 길이에 따라 배열의 순서가 바뀐다 , 퀵 sort() , 머지 sort가 성능에 좋다.

// 에러가 안나는 sort 코드 !!!!  (문자나 한글도 오류없음)
// jsonData.sort((a, b) => (a[key] > b[key] ? -1 : (a[key] < b[key] ? 1 : 0)))


const data = ['a', 'z', 'b', 'e'];
data.sort();
console.log(data);
const data1 = [1,11,2,22];
console.log(data1); //[ 1, 11, 2, 22 ] 사전식 정렬이여서 정렬이 되지않는다

data1.sort((a, b) => (a > b ? -1 : (a < b ? 1 : 0))) // 내림차순
console.log(data1); //[ 22, 11, 2, 1 ]
data1.sort((a, b) => (a < b ? -1 : (a > b ? 1 : 0))) // 오름차순
console.log(data1); //[ 1, 2, 11, 22 ]

// 여러분들이 자주 사용하는 코드
let data2 = [1, 11, 2, 111, 22];
data2.sort((a, b) => (a - b)); // 오름차순
data2.sort((a, b) => (b - a)); // 내림차순

// 원리
const test = [13, 9, 10, 2];
test.sort((a, b) => {
  console.log(`a : ${a}, b : ${b}`);
})
// a : 9, b : 13
// a : 10, b : 9
// a : 2, b : 10

console.log('--------------------------');




// (a, b) => (a - b)가 콜백함수입니다.
// a - b 값이 0보다 작은 경우 a를 b보다 낮은 색인으로 정렬합니다. 즉, a가 먼저옵니다.
// a - b 값이 0을 반환하면 a와 b를 서로에 대해 변경하지 않고 모든 다른 요소에 대해 정렬합니다.
// a - b 값이 0보다 큰 경우, b를 a보다 낮은 인덱스로 소트합니다. 즉, b가 먼저옵니다.

// 원리
let test = [13, 9, 10, 2];
test.sort((a, b) => {
    console.log(a, b)
})
// 출력해보면 a, b의 값이 순차적으로 들어갈 것 같지만 그렇지 않습니다.
// 9 13
// 10 9
// 2 10

let test = [13, 9, 10, 2];
test.sort((a, b) => {
    console.log(a, b)
    console.log(a - b) // 0보다 작은 경우 a를 b보다 낮은 색인으로 정렬합니다. 즉, a가 먼저옵니다.
});

let test = [13, 9, 10, 2];
test.sort((a, b) => {
    return a - b; // 작은 값이 앞으로 간다 => 오름차순
})